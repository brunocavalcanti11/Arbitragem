import streamlit as st
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import zscore
import sys
import os
from datetime import datetime, timedelta
import matplotlib.dates as mdates


# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Dashboard de Pair Trading com Brent",
    page_icon="üìà",
    layout="wide"
)

# T√≠tulo do dashboard
st.title("Dashboard de Pair Trading com Cota√ß√£o do Brent")

# Sidebar para configura√ß√µes
st.sidebar.header("Configura√ß√µes")

# Inicializa o estado da sess√£o se n√£o existir
if "first_load_done" not in st.session_state:
    st.session_state.first_load_done = False

# Bot√£o de atualiza√ß√£o manual
if st.sidebar.button("üîÑ Atualizar Dados"):
    st.cache_data.clear() # Limpa o cache para buscar dados novos
    st.session_state.first_load_done = True # Marca que o bot√£o foi clicado
    st.rerun()

st.sidebar.markdown("--- ") # Separador

# Lista de a√ß√µes dispon√≠veis (bancos e Petrobras da Bovespa)
acoes_disponiveis = {
    'Bancos': ['ITUB3.SA', 'ITUB4.SA', 'BBDC3.SA', 'BBDC4.SA', 'BBAS3.SA', 'SANB3.SA', 'SANB4.SA', 'BPAC3.SA', 'BPAC5.SA', 'BPAC11.SA'],
    'Petrobras': ['PETR3.SA', 'PETR4.SA']
}

# Op√ß√µes de per√≠odo
periodos = {
    '1 m√™s': '1mo',
    '3 meses': '3mo',
    '6 meses': '6mo',
    '1 ano': '1y',
    '2 anos': '2y',
    '5 anos': '5y',
    'Desde 2016': 'max'  # Usando 'max' para obter dados desde o in√≠cio e depois filtraremos para 2016
}

# Sele√ß√£o de categoria
categoria = st.sidebar.selectbox("Categoria", list(acoes_disponiveis.keys()), index=1 if 'Petrobras' in acoes_disponiveis else 0)

# Sele√ß√£o de a√ß√µes baseada na categoria
acoes_selecionadas = st.sidebar.multiselect(
    "Selecione as a√ß√µes para an√°lise (m√°ximo 2)",
    acoes_disponiveis[categoria],
    default=acoes_disponiveis[categoria][:2] if len(acoes_disponiveis[categoria]) >= 2 else acoes_disponiveis[categoria]
)

# Limitar a sele√ß√£o a 2 a√ß√µes
if len(acoes_selecionadas) > 2:
    st.sidebar.warning("Por favor, selecione no m√°ximo 2 a√ß√µes para a an√°lise de pair trading.")
    acoes_selecionadas = acoes_selecionadas[:2]

# Sele√ß√£o de per√≠odo
periodo_selecionado = st.sidebar.selectbox("Per√≠odo de an√°lise", list(periodos.keys()))
periodo_valor = periodos[periodo_selecionado]

# Configura√ß√£o de Z-score
st.sidebar.subheader("Configura√ß√£o de Z-score")
limite_superior_zscore = st.sidebar.slider("Limite Superior Z-score", 0.5, 3.0, 1.0, 0.1)
limite_inferior_zscore = -limite_superior_zscore

# Op√ß√µes de s√≠mbolos para petr√≥leo/commodities
commodities_disponiveis = {
    'USO': 'United States Oil Fund (cerca de $69)',
    'BNO': 'United States Brent Oil Fund',
    'UCO': 'ProShares Ultra Bloomberg Crude Oil',
    'XLE': 'Energy Select Sector SPDR Fund',
    'XOP': 'SPDR S&P Oil & Gas Exploration & Production ETF',
    'OIH': 'VanEck Oil Services ETF'
}

# Sele√ß√£o do s√≠mbolo da commodity
commodity_symbol = st.sidebar.selectbox(
    "Selecione a commodity de refer√™ncia",
    list(commodities_disponiveis.keys()),
    format_func=lambda x: f"{x} - {commodities_disponiveis[x]}"
)

# Fun√ß√£o para obter cota√ß√£o atual
@st.cache_data(ttl=300)  # Cache por 5 minutos
def obter_cotacao(acao):
    """Obt√©m a cota√ß√£o atual de uma a√ß√£o, com tratamento de erro para rate limit."""
    try:
        dados = yf.Ticker(acao)
        # Tenta obter o pre√ßo mais recente (pega 2 dias para garantir que h√° dados)
        hist = dados.history(period="2d") 
        if hist.empty:
            st.warning(f"N√£o foi poss√≠vel obter cota√ß√£o atual para {acao}. Pode ser um problema tempor√°rio ou limite de requisi√ß√µes. Tente atualizar mais tarde.")
            return None
        preco_atual = hist["Close"].iloc[-1] # Usar -1 para garantir o √∫ltimo dispon√≠vel
        return preco_atual
    except Exception as e:
        # Verifica se o erro √© relacionado a rate limit
        error_msg = str(e).lower()
        if "too many requests" in error_msg or "rate limited" in error_msg or "429" in error_msg:
            st.warning(f"Limite de requisi√ß√µes atingido para cota√ß√£o de {acao}. Tente atualizar novamente em alguns minutos.")
        else:
            # Outro erro
            st.error(f"Erro ao obter cota√ß√£o de {acao}: {e}")
        return None

# Fun√ß√£o para obter s√©rie hist√≥rica
@st.cache_data(ttl=300)  # Cache por 5 minutos
def obter_serie_historica(acao, periodo='1y'):
    """Obt√©m a s√©rie hist√≥rica de uma a√ß√£o usando yfinance, com tratamento de erro para rate limit."""
    try:
        # Obt√©m os dados hist√≥ricos com pre√ßos ajustados para desdobramentos/bonifica√ß√µes
        ticker = yf.Ticker(acao)
        
        # Se o per√≠odo for 'max', obtemos o m√°ximo de dados e filtramos
        if periodo == 'max': # Use 'max' as string value for period
            dados = ticker.history(period=periodo, auto_adjust=True)
            # Filtra para dados a partir de 2016-01-01
            dados = dados.loc['2016-01-01':]
        else:
            dados = ticker.history(period=periodo, auto_adjust=True)

        # Verifica se os dados foram retornados (yfinance pode retornar vazio em caso de erro)
        if dados.empty:
            st.warning(f"N√£o foi poss√≠vel obter dados hist√≥ricos para {acao}. Pode ser um problema tempor√°rio ou limite de requisi√ß√µes. Tente atualizar mais tarde.")
            return None
            
        # Exibe informa√ß√µes sobre a√ß√µes corporativas se dispon√≠veis
        try:
            acoes_corporativas = ticker.actions
            if not acoes_corporativas.empty:
                # Filtra para a√ß√µes corporativas a partir de 2016
                acoes_corporativas = acoes_corporativas.loc['2016-01-01':]
                if not acoes_corporativas.empty:
                    # Verifica se existem desdobramentos
                    has_splits = False
                    if 'Stock Splits' in acoes_corporativas.columns:
                        splits = acoes_corporativas[acoes_corporativas['Stock Splits'] > 0]
                        has_splits = not splits.empty
                    
                    # Cria um expander para mostrar todas as a√ß√µes corporativas (dividendos, etc.)
                    with st.sidebar.expander(f"A√ß√µes Corporativas - {acao}", expanded=False):
                        st.dataframe(acoes_corporativas)
                    
                    # Cria um expander separado e destacado para desdobramentos, se houver
                    if has_splits:
                        with st.sidebar.expander(f"üîç DESDOBRAMENTOS - {acao}", expanded=True):
                            st.write(f"**Desdobramentos desde 2016:**")
                            for data, row in splits.iterrows():
                                st.write(f"- {data.strftime('%d/%m/%Y')}: **{row['Stock Splits']}:1**")
                            
                            # Adiciona uma nota explicativa sobre o impacto no ratio
                            st.info(f"""
                            **Nota:** Os desdobramentos acima s√£o automaticamente considerados no c√°lculo do ratio.
                            Por exemplo, um desdobramento de 2:1 significa que o pre√ßo da a√ß√£o foi ajustado para metade
                            do valor para manter a consist√™ncia hist√≥rica.
                            """)
        except Exception as e_actions:
            # Silenciosamente ignora erros ao buscar a√ß√µes corporativas, pois n√£o s√£o essenciais
            pass
            
        return dados
        
    except Exception as e:
        # Verifica se o erro √© relacionado a rate limit
        error_msg = str(e).lower()
        if "too many requests" in error_msg or "rate limited" in error_msg or "429" in error_msg:
            st.warning(f"Limite de requisi√ß√µes atingido para dados hist√≥ricos de {acao}. Tente atualizar novamente em alguns minutos.")
        else:
            # Outro erro
            st.error(f"Erro ao obter s√©rie hist√≥rica de {acao}: {e}")
        return None

# --- L√≥gica Principal --- 
# S√≥ executa a l√≥gica principal se o bot√£o de atualiza√ß√£o j√° foi clicado uma vez
if st.session_state.first_load_done:
    # Exibir cota√ß√µes atuais
    if acoes_selecionadas:
        st.subheader("Cota√ß√µes Atuais")

        # Criar colunas para exibir as cota√ß√µes
        cols = st.columns(len(acoes_selecionadas) + 1)  # +1 para a commodity

        # Exibir cota√ß√µes das a√ß√µes selecionadas
        cotacoes_ok = True # Resetar flag a cada atualiza√ß√£o
        for i, acao in enumerate(acoes_selecionadas):
            preco = obter_cotacao(acao)
            if preco is None:
                cotacoes_ok = False # Marca se alguma cota√ß√£o falhou
                # Mensagem de erro j√° √© exibida por obter_cotacao
                cols[i].metric(label=acao, value="Erro")
            else:
                # Ajuste para exibir moeda correta (R$ para .SA)
                currency_prefix_stock = "R$" if ".SA" in acao else "$" 
                cols[i].metric(label=acao, value=f"{currency_prefix_stock} {preco:.2f}")

        # Exibir cota√ß√£o da commodity
        commodity_preco = obter_cotacao(commodity_symbol)
        if commodity_preco is None:
            cotacoes_ok = False # Marca se a cota√ß√£o da commodity falhou
            # Mensagem de erro j√° √© exibida por obter_cotacao
            cols[len(acoes_selecionadas)].metric(label=commodity_symbol, value="Erro")
        else:
            # Determina a moeda com base no s√≠mbolo (simplificado)
            # Assumindo que todos os ETFs listados s√£o USD
            currency_prefix_comm = "US$" 
            cols[len(acoes_selecionadas)].metric(label=commodity_symbol, value=f"{currency_prefix_comm} {commodity_preco:.2f}")

    # An√°lise de Pair Trading
    if len(acoes_selecionadas) == 2 and cotacoes_ok: # S√≥ prossegue se as cota√ß√µes foram obtidas
        st.subheader(f"An√°lise de Pair Trading: {acoes_selecionadas[0]} vs {acoes_selecionadas[1]}")

        # Nota sobre o c√°lculo do ratio
        st.info("""
        **Nota sobre o c√°lculo do ratio:** O ratio √© calculado usando pre√ßos ajustados para desdobramentos desde 2016. 
        Isso garante que a an√°lise leva em conta todas as mudan√ßas na estrutura de capital das empresas, 
        especialmente os desdobramentos (stock splits) que afetam diretamente a quantidade de a√ß√µes.
        
        Os desdobramentos s√£o destacados na barra lateral para cada ativo.
        """)

        # Obter s√©ries hist√≥ricas
        serie_acao1 = obter_serie_historica(acoes_selecionadas[0], periodo=periodo_valor)
        serie_acao2 = obter_serie_historica(acoes_selecionadas[1], periodo=periodo_valor)
        serie_commodity = obter_serie_historica(commodity_symbol, periodo=periodo_valor)

        if serie_acao1 is not None and serie_acao2 is not None and serie_commodity is not None:
            # Alinhar as s√©ries temporais (usando interse√ß√£o dos √≠ndices)
            common_index = serie_acao1.index.intersection(serie_acao2.index).intersection(serie_commodity.index)
            serie_acao1 = serie_acao1.loc[common_index]
            serie_acao2 = serie_acao2.loc[common_index]
            serie_commodity = serie_commodity.loc[common_index]

            if not common_index.empty:
                # Calcular o ratio entre as a√ß√µes (usando pre√ßos ajustados)
                ratio = serie_acao1["Close"] / serie_acao2["Close"]

                # Calcular Z-score do ratio
                z_score_ratio = zscore(ratio)

                # Calcular m√©dia e desvios padr√£o do ratio
                media_ratio = ratio.mean()
                std_ratio = ratio.std()
                limite_superior = media_ratio + limite_superior_zscore * std_ratio
                limite_inferior = media_ratio + limite_inferior_zscore * std_ratio

                # Exibir m√©tricas atuais
                ratio_atual = ratio.iloc[-1]
                z_score_atual = z_score_ratio[-1]

                # Determinar sinal
                sinal = "Neutro"
                if z_score_atual > limite_superior_zscore:
                    sinal = f"Vender {acoes_selecionadas[0]} / Comprar {acoes_selecionadas[1]}"
                elif z_score_atual < limite_inferior_zscore:
                    sinal = f"Comprar {acoes_selecionadas[0]} / Vender {acoes_selecionadas[1]}"

                col1, col2, col3 = st.columns(3)
                col1.metric("Ratio Atual", f"{ratio_atual:.4f}")
                col2.metric("Z-Score Atual", f"{z_score_atual:.4f}")
                col3.metric("Sinal", sinal)

                # Plotar o gr√°fico
                st.subheader(f"Ratio entre {acoes_selecionadas[0]} e {acoes_selecionadas[1]} com {commodity_symbol} - {periodo_selecionado}") # Usar periodo_selecionado para o texto
                fig, ax1 = plt.subplots(figsize=(12, 6))

                # Eixo esquerdo para o Ratio
                color = "tab:blue"
                ax1.set_xlabel("Data")
                ax1.set_ylabel("Ratio", color=color)
                ax1.plot(ratio.index, ratio, label="Ratio", color=color)
                ax1.axhline(media_ratio, color="gray", linestyle="--", label="M√©dia")
                ax1.axhline(limite_superior, color="red", linestyle="--", label=f"+{limite_superior_zscore:.1f} Desvios Padr√µes")
                ax1.axhline(limite_inferior, color="green", linestyle="--", label=f"-{abs(limite_inferior_zscore):.1f} Desvios Padr√µes") # Use abs() for negative limit label
                ax1.tick_params(axis="y", labelcolor=color)
                ax1.legend(loc="upper left")
                ax1.grid(True)

                # Eixo direito para a Commodity
                ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
                color = "tab:orange"
                ax2.set_ylabel(f"{commodity_symbol} (Pre√ßo)", color=color)  # we already handled the x-label with ax1
                ax2.plot(serie_commodity.index, serie_commodity["Close"], label=commodity_symbol, color=color, alpha=0.7)
                ax2.tick_params(axis="y", labelcolor=color)
                ax2.legend(loc="upper right")

                fig.tight_layout()  # otherwise the right y-label is slightly clipped

                # Formatar eixo X para mostrar datas de forma leg√≠vel
                ax1.xaxis.set_major_locator(mdates.AutoDateLocator())
                ax1.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m-%d"))
                plt.setp(ax1.get_xticklabels(), rotation=45, ha="right")

                st.pyplot(fig)

                # Tabela de dados hist√≥ricos
                st.subheader("Dados Hist√≥ricos")
                dados_tabela = pd.DataFrame({
                    f"{acoes_selecionadas[0]}": serie_acao1["Close"],
                    f"{acoes_selecionadas[1]}": serie_acao2["Close"],
                    "Ratio": ratio,
                    "Z-Score": z_score_ratio,
                    f"{commodity_symbol}": serie_commodity["Close"]
                })
                st.dataframe(dados_tabela)

                # Bot√£o de download CSV
                @st.cache_data
                def convert_df_to_csv(df):
                    return df.to_csv(index=True).encode("utf-8")

                csv = convert_df_to_csv(dados_tabela)
                st.download_button(
                    label="Download dados como CSV",
                    data=csv,
                    file_name=f"pair_trading_{acoes_selecionadas[0]}_{acoes_selecionadas[1]}_{periodo_selecionado}.csv", # Usar periodo_selecionado
                    mime="text/csv",
                )
            else:
                st.warning("N√£o h√° dados comuns suficientes no per√≠odo selecionado para as a√ß√µes e commodity.")
        else:
            # Mensagens de erro/aviso j√° foram exibidas pelas fun√ß√µes de obten√ß√£o de dados
            st.error("N√£o foi poss√≠vel realizar a an√°lise devido a erros na obten√ß√£o dos dados. Verifique os avisos acima.")

    elif len(acoes_selecionadas) != 2 and cotacoes_ok: # Adicionado cotacoes_ok aqui tamb√©m
        st.warning("Por favor, selecione exatamente duas a√ß√µes para an√°lise de pair trading.")
    # Se cotacoes_ok for False, as mensagens de erro j√° foram exibidas na se√ß√£o de cota√ß√µes

else:
    # Mensagem exibida antes do primeiro clique no bot√£o
    st.info("üìà Por favor, clique no bot√£o 'üîÑ Atualizar Dados' na barra lateral para carregar as informa√ß√µes.")

# Informa√ß√µes adicionais
st.sidebar.markdown("---")
st.sidebar.subheader("Sobre")
st.sidebar.info("""
Este dashboard permite analisar estrat√©gias de pair trading entre a√ß√µes de bancos e Petrobras da Bovespa, 
incluindo a cota√ß√£o do petr√≥leo Brent como refer√™ncia adicional.
""")

